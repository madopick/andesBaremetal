Getting Started with AMSI Driver package
========================================

The AMSI Driver package is a software API that describes peripheral driver
interfaces for middleware stacks and user applications. It contains all files
necessary for Andes platfrom peripherial drivers and example programs based on
the APIs. The directories of the package are organized as follows:

 * README.v5 - This file.
 * Makefile  - Makefile to build the package.
 * bsp/      - The directory contains the BSP sources of Andes CPU based
               platforms, including CPU and board bootstrap code.
 * driver/   - The directory contains the driver source code of Andes platforms.
               It includes each platform peripherial driver sources and header
               files for calling the various driver functions.
 * examples/ - The directory contains the example programs for each driver to
               demonstrate the AMSI Driver API programming.

This package is used for targeting Andes V5 CPU based platforms using the
RV32/RV64 baseline compiler. The following AndesStar architectures are
supported:

 - V5 : N25 / NX25 / A25 / AX25

Requirements
============
To start using AMSI Driver package, you will need the following:

 - The Andes V5/V5M toolchain to compile AMSI Driver package.
 - Andes platform (AE250/AE350).
 - ICEman utility to download the image to platform.

Building the examples
=====================
Currently, two platform drivers are implemented:

 - AE250  : driver/v5/ae250
 - AE350  : driver/v5/ae350

And there are 6 platform-independent demo programs are supported:

 - UART : examples/uart
 - GPIO : examples/gpio
 - RTC  : examples/rtc
 - I2C  : examples/i2c
 - SPI  : examples/spi
 - PWM  : examples/pwm

The scenario of each demos is described in 'Abstract.txt' file under each
example directory.

To building these demos, you need to run 'make' command under root directory
of this package and set the 'COMPILER','PLAT' and 'DEMO' make variables to
specify the compiler, alias name of platform and demo program to build. The
help warning message will show up if 'COMPILER' or 'PLAT' make variable are
not specified. Without specified, 'DEMO=UART'is set as default.
For example:

 # make COMPILER=riscv32 PLAT=AE250
   or
 # make COMPILER=riscv32 PLAT=AE250 DEMO=UART

The silence building is automatically selected as default. If you want to
trun-on verbose builds, you can set 'V=1' in make command to enable.
Such as :

 # make COMPILER=riscv32 V=1

Building with configured
------------------------
The deafult image to build is for non-cache and non-debugging based system. Additionally,
you can use the following make variables to specify the system configures to build.

 - DEBUG=1         : Enable debug configure
 - USE_CACHE=1     : Enable cache configure.
 - USE_FLASHEXEC=1 : Enable execute on FLASH directly configure.

The make variables can be single or multiple set when make. For example, building for
debugging and cache mode enabled with verbose turned on.

 # make COMPILER=riscv32 V=1 DEBUG=1 USE_CACHE=1

Built images
------------
If nothing goes wrong, the 'build' directory will be created in the root
directory of this package and the built images are available in there,
including object, ELF and binary files.
